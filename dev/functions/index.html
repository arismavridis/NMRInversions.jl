<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · NMRInversions.jl</title><meta name="title" content="Functions · NMRInversions.jl"/><meta property="og:title" content="Functions · NMRInversions.jl"/><meta property="twitter:title" content="Functions · NMRInversions.jl"/><meta name="description" content="Documentation for NMRInversions.jl."/><meta property="og:description" content="Documentation for NMRInversions.jl."/><meta property="twitter:description" content="Documentation for NMRInversions.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="NMRInversions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NMRInversions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Importing-data-functions"><span>Importing data functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Inversion-functions"><span>Inversion functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Exponential-fit-functions"><span>Exponential fit functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Plotting-functions"><span>Plotting functions</span></a></li></ul></li><li><a class="tocitem" href="../types_structs/">Types and Structures</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/arismavridis/NMRInversions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/arismavridis/NMRInversions.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Intro"><a class="docs-heading-anchor" href="#Intro">Intro</a><a id="Intro-1"></a><a class="docs-heading-anchor-permalink" href="#Intro" title="Permalink"></a></h1><p>This page contains the documentation for various useful  functions in the NMRInversions package.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>From the julia command line, you can enter &#39;?&#39;,  followed by the name of any function, struct,  or object you want to learn more about (try it!). After typing <code>using NMRInversions</code> in the julia console,  this feature will work for all the functions mentioned below.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In julia, function definitions look like this:</p><pre><code class="nohighlight hljs">foo(x, y, z ; a, b)</code></pre><p>For the example above, <code>foo</code> is the name of the function,  and the contents of the parenteses are the arguments.   Within the parenteses, we got two types of arguments:</p><ul><li>Positional arguments</li></ul><p>Everything that appears before the semicolon <code>;</code>  (x,y and z in this example) is necessary, and must be given in a specific order.</p><ul><li>Keyword arguments.</li></ul><p>Everything that appears after the semicolon <code>;</code>  (b and a in this example) is optional, and can be given in any order, but its name must be specified.</p><p>In the example above, we can call the function by typing <code>foo(1, 2, 3)</code>, (in which case, x=1, y=2, z=3, and the default value for <code>a</code> and <code>b</code> will be used).  You can also call the function by typing <code>foo(1, 2, 3, a=3)</code>, to specify the value for <code>a</code>,  or by typing <code>foo(1, 2, 3, b=3, a = 2)</code>, to specify the value for both <code>a</code> and <code>b</code>.</p><p>Sometimes, if there are many keyword arguments, we write  the function as foo(x, y ; kwargs...).  For the necessary arguments before the semicolon, order matters.  For the keyword arguments after the semicolon, order does not matter,  but the name of each argument must be specified. For more information, please refer to <a href="https://docs.julialang.org/en/v1/manual/functions/">this link</a>.</p></div></div><h1 id="Importing-data-functions"><a class="docs-heading-anchor" href="#Importing-data-functions">Importing data functions</a><a id="Importing-data-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-data-functions" title="Permalink"></a></h1><p>This package offers some functions to import NMR experiment data of various formats. If a format you&#39;re working with is not yet supported,  please <a href="https://github.com/arismavridis/NMRInversions.jl/issues/new">submit an issue</a>  and we&#39;ll work on it.</p><h1 id="Inversion-functions"><a class="docs-heading-anchor" href="#Inversion-functions">Inversion functions</a><a id="Inversion-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion-functions" title="Permalink"></a></h1><p>The most important function is <code>invert()</code>, which is the main function of the package. It works as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence1D}, AbstractArray, Vector}" href="#NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence1D}, AbstractArray, Vector}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Inversion for 1D pulse sequences:</strong></p><pre><code class="nohighlight hljs">invert(seq, x, y ; lims, alpha, solver)</code></pre><p>This function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an <code>inv_out_1D</code> structure.</p><p>Necessary (positional) arguments:</p><ul><li><code>seq</code> is the 1D pulse sequence (e.g. IR, CPMG, PGSE)</li><li><code>x</code> is the experiment x axis (time or b factor etc.)</li><li><code>y</code> is the experiment y axis (intensity of the NMR signal)</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>lims=(a,b,c)</code> will set the &quot;limits&quot; of the output X, </li></ul><p>so that it starts from 10^a, ends in 10^b and consists of c  logarithmically spaced values (default is (-5, 1, 128)).  Alternatiively, a vector of values can be used directly  (e.g. <code>lims=[10^-5, ... ,10]</code> ).</p><ul><li><code>alpha</code> determines the smoothing term. Use a real number for a fixed alpha.  No selection will lead to automatically determining alpha through the defeault method, which is <code>gcv</code>.</li><li><code>solver</code> is the algorithm used to do the inversion math. Default is <code>brd</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/inversion_functions.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{input1D}" href="#NMRInversions.invert-Tuple{input1D}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert(data::input1D ; kwargs...)</code></pre><p>Instead of the positional arguments <code>seq</code>, <code>x</code> and <code>y</code>, you can use a single <code>input1D</code> structure, which contains the same information.  Especially useful if you&#39;re using the output of one  of the import functions (look documentation tutorial section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/inversion_functions.jl#L64-L71">source</a></section></article><p>Due to julia&#39;s multiple dispatch,  it is possible to define a function with the same name but different arguments, to achieve different results.</p><p>Because of that, the inversion function also works for 2D inversions, if the following arguments are used instead:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}" href="#NMRInversions.invert-Tuple{Type{&lt;:pulse_sequence2D}, AbstractVector, AbstractVector, AbstractMatrix}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Inversion for 2D pulse sequences:</strong></p><pre><code class="nohighlight hljs">invert(seq, x_direct, x_indirect, X_direct, X_indirect, Data)</code></pre><p>This function will build a kernel and use it to perform an inversion using the algorithm of your choice. The output is an <code>inv_out_2D</code> structure.</p><p>Necessary (positional) arguments:</p><ul><li><code>seq</code> is the 2D pulse sequence (e.g. IRCPMG)</li><li><code>x_direct</code> is the direct dimension acquisition parameter (e.g. the times when you aquire CPMG echoes).</li><li><code>x_indirect</code> is the indirect dimension acquisition parameter (e.g. all the delay times τ in your IR sequence).</li><li><code>Data</code> is the 2D data matrix of complex data.</li></ul><p>Optional (keyword) arguments:</p><ul><li><code>rdir</code> determines the output &quot;range&quot; of the inversion in the direct dimension (e.g. T₂ times in IRCPMG)</li><li><code>rindir</code> determines the output &quot;range&quot; of the inversion in the indirect dimension (e.g. T₁ times in IRCPMG)</li></ul><p>In both cases above, you can use a tuple specifying the limits of the range, or a vector of values, same as the <code>lims</code> argument in the 1D inversion.</p><ul><li><code>alpha</code> determines the smoothing term. Use a real number for a fixed alpha.  No selection will lead to automatically determining alpha through the defeault method, which is <code>gcv</code>.</li><li><code>solver</code> is the algorithm used to do the inversion math. Default is <code>brd</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/inversion_functions.jl#L80-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.invert-Tuple{input2D}" href="#NMRInversions.invert-Tuple{input2D}"><code>NMRInversions.invert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert(data::input2D ; kwargs...)</code></pre><p>Instead of the positional arguments <code>seq</code>, <code>x_direct</code> , <code>x_indirect</code> and <code>Data</code>, you can use a single <code>input2D</code>  structure, which contains the same information.  Especially useful if you&#39;re using the output of one of the  import functions (look documentation tutorial section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/inversion_functions.jl#L148-L156">source</a></section></article><h1 id="Exponential-fit-functions"><a class="docs-heading-anchor" href="#Exponential-fit-functions">Exponential fit functions</a><a id="Exponential-fit-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-fit-functions" title="Permalink"></a></h1><p>For 1D data, we can use the <code>expfit</code> function to perform multiexponential fits. We can use the function by specifying either the number of exponential components, or a vector which defines the starting points for the regression. See below:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Int64, Type{&lt;:pulse_sequence1D}, Vector, Vector}" href="#NMRInversions.expfit-Tuple{Int64, Type{&lt;:pulse_sequence1D}, Vector, Vector}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(n, seq, x, y;solver)</code></pre><p>Fit an exponential function to the data <code>x</code>, <code>y</code> using <code>n</code> exponential terms. </p><p>Starting points for the nonlinear regression are automatically chosen. The outut is an <code>expfit_struct</code> structure.</p><p>Arguments:</p><ul><li><code>n</code> : number of exponential terms.</li><li><code>seq</code> : pulse sequence.</li><li><code>x</code> : acquisition x parameter (time for relaxation or b-factor for diffusion).</li><li><code>y</code> : acquisition y parameter (magnetization).</li><li><code>solver</code> : optimization solver (default is BFGS).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/exp_fits.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Int64, input1D}" href="#NMRInversions.expfit-Tuple{Int64, input1D}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(u0, data::input1D; kwargs...)</code></pre><p>Similar to the <code>invert</code> fucntion, <code>expfit</code> can be called using an <code>input1D</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/exp_fits.jl#L151-L154">source</a></section></article><p>If you have some rough clues about what results you expect,  it&#39;s best to define some starting points close to these, as shown below. (especially important if you&#39;re using double or tri-exponential fits.)</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Vector{Real}, Type{&lt;:pulse_sequence1D}, Vector, Vector}" href="#NMRInversions.expfit-Tuple{Vector{Real}, Type{&lt;:pulse_sequence1D}, Vector, Vector}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(u0, seq, x, y; solver=BFGS())</code></pre><p>Fit an exponential function to the data <code>x</code>, <code>y</code>. </p><p>The outut is an <code>expfit_struct</code> structure.</p><p>Arguments:</p><ul><li><code>u0</code> : initial parameter guesses.</li><li><code>seq</code> : pulse sequence.</li><li><code>x</code> : acquisition x parameter (time for relaxation or b-factor for diffusion).</li><li><code>y</code> : acquisition y parameter (magnetization).</li><li><code>solver</code> : OptimizationOptimJL solver, defeault choice is BFGS().</li></ul><p>The <code>u0</code> argument is a vector of initial parameter guesses,  and it also determines the number of exponential terms used. It should be of the form [a1, b1, a2, b2, ...],  where a&#39;s are the amplitudes and b&#39;s are the reciprocals of the decay constants. The length of <code>u0</code> must be an even number.</p><p>The following examples might help to clarify: </p><p><code>expfit([a,b] , CPMG, x, y)</code> -&gt; mono-exponential fit with initial guess: a * exp.( (1/b) * x) </p><p><code>expfit([a,b,c,d] , CPMG, x, y)</code> -&gt; double-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) </p><p><code>expfit([a,b,c,d,e,f] , CPMG, x, y)</code> -&gt; triple-exponential fit with initial guess: a * exp.( (1/b) * x) + c * exp.((1/d) * x) + e * exp.((1/f) * x) </p><p>(where a,b,c,d,e,f are numbers of your choice) Numbers of parameters beyond tri-exponential can also be used, but it is not recommended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/exp_fits.jl#L77-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NMRInversions.expfit-Tuple{Vector{Real}, input1D}" href="#NMRInversions.expfit-Tuple{Vector{Real}, input1D}"><code>NMRInversions.expfit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expfit(n, data::input1D; kwargs...)</code></pre><p>Similar to the <code>invert</code> fucntion, <code>expfit</code> can be called using an <code>input1D</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/src/exp_fits.jl#L68-L71">source</a></section></article><h1 id="Plotting-functions"><a class="docs-heading-anchor" href="#Plotting-functions">Plotting functions</a><a id="Plotting-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-functions" title="Permalink"></a></h1><p>This package offers plotting capabilities, using its GLMakie extension. Simply use <code>using GLMakie</code> to load the package, and these functions become available.</p><p>We basically take the <code>plot()</code> function offered by GLMakie and extend it to types from the package.</p><p>For example, for 1D inversions, we have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot-Tuple{inv_out_1D}" href="#MakieCore.plot-Tuple{inv_out_1D}"><code>MakieCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(res::NMRInversions.inv_out_1D...; kwargs...)</code></pre><p>Plot the results contained in a <code>inv_out_1D</code> structure. This function can take any number of <code>inv_out_1D</code> structures as input. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot!-Tuple{Union{GridPosition, Figure}, inv_out_1D}" href="#MakieCore.plot!-Tuple{Union{GridPosition, Figure}, inv_out_1D}"><code>MakieCore.plot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot!(fig, res...; title)</code></pre><p>Plot the results contained in a <code>inv_out_1D</code> structure on a figure or a grid position object. This function can take any number of <code>inv_out_1D</code> structures as input.</p><p>The arguments are:</p><ul><li><code>fig</code> : The figure or grid position object.</li><li><code>res</code> : One or more <code>inv_out_1D</code> structures containing the fit results.</li></ul><p>Keyword (optional) arguments:</p><ul><li><code>title</code> : Title of the plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L91-L104">source</a></section></article><p>For expfits, we have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot-Tuple{expfit_struct}" href="#MakieCore.plot-Tuple{expfit_struct}"><code>MakieCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(res::expfit_struct...; kwargs...)</code></pre><p>Plot the results of an <code>expfit</code> call. </p><p>This function can take any number of <code>expfit_struct</code> structures as input. </p><p>e.g. <code>plot(data1)</code> plots the data and the corresponding fit, but <code>plot(data1, data2)</code> or <code>plot(data1, data2, data3)</code> work as well, and they plot all of the results on the same plot.</p><p>This function creates a figure,  and calls <code>plot!(fig, res)</code> for each of the results in <code>res</code>, so please refer to the <code>plot!</code> documentation for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}" href="#MakieCore.plot!-Tuple{Union{GridPosition, Figure}, expfit_struct}"><code>MakieCore.plot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot!(fig, res...; names, markersize, normeq)</code></pre><p>Plots the results of an <code>expfit</code> call on a figure or a grid position object.</p><p>The arguments are:</p><ul><li><code>fig</code> : The figure or grid position object.</li><li><code>res</code> : One or more <code>expfit_struct</code> structures containing the fit results.</li><li><code>names</code> : Vector with the names of the data (default is a vector of &quot;Data&quot; for each result).</li><li><code>markersize</code> : The size of the markers (default is 7).</li><li><code>normeq</code> : Whether to plot the normalised form of the equation or not (default is <code>true</code>).</li></ul><p>Note that the res inputs are not a vector, but individual <code>expfit_struct</code> structures, like: plot!(fig, data1, data2, data3). If you want to use a vector of <code>expfit_struct</code> structures, make sure to  splat it by using <code>...</code> in the function call (e.g. <code>plot!(fig, [data1, data2, data3]...)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L29-L46">source</a></section></article><p>And for 2D inversions, there&#39;s an interactive gui to characterize the inversion resutls:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot-Tuple{inv_out_2D}" href="#MakieCore.plot-Tuple{inv_out_2D}"><code>MakieCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Makie.plot(res::inv_out_2D)</code></pre><p>Run the GUI to plot the results and select peaks you want to label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L293-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot-Tuple{inv_out_2D, String}" href="#MakieCore.plot-Tuple{inv_out_2D, String}"><code>MakieCore.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(results::NMRInversions.inv_out_2D, title::String; kwargs...)</code></pre><p>Plot the results contained in a <code>inv_out_2D</code> structure.</p><p>The arguments are:</p><ul><li><code>results</code> : The <code>inv_out_2D</code> structure containing the fit results.</li><li><code>title</code> : Title of the plot.</li></ul><p>kwargs are passed onto <code>plot!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieCore.plot!-Tuple{Union{GridPosition, Figure}, inv_out_2D}" href="#MakieCore.plot!-Tuple{Union{GridPosition, Figure}, inv_out_2D}"><code>MakieCore.plot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot!(fig, res::NMRInversions.inv_out_2D; title, clmap)</code></pre><p>Plot the results contained in a <code>inv_out_2D</code> structure on a figure or a grid position object.</p><p>The arguments are:</p><ul><li><code>fig</code> : The figure or grid position object.</li><li><code>res</code> : The <code>inv_out_2D</code> structure containing the fit results.</li></ul><p>Keyword (optional) arguments:</p><ul><li><code>title</code> : Title of the plot (default: &quot;&quot;).</li><li><code>clmap</code> : Color map of the plot (default: :tempo).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arismavridis/NMRInversions.jl/blob/6b40e18429b5e8713e78ca6dbe0e24329ae2ec2a/ext/gui_ext.jl#L160-L173">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../types_structs/">Types and Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 9 October 2024 15:35">Wednesday 9 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
